---
title: C++ Review Notes 
short: "C++ does not usually use much, review for the interview.!"
date: 05.10.2017
tags:
    - c++
    - notes
---

# ***C++ 复习笔记***
---

## 名字空间（namespace)
&emsp;防止命名冲突 std：c++标准库
&emsp;using namespace std; 表示引入标准库的所有命名，否则的话如cout就需要使用 std::cout或者写成 #include &lt;iostream.h>

## public、private、protected

1. public: 共有成员函数或变量。对外开放，既可以被本类访问，也可以通过类的对象调用或访问。
2. private: 私有成员函数后变量。能被被类的函数调用或访问，子类，派生类也不可以访问。当private紧邻{ 时 可以省略private关键字，即class默认类型为priavte
3. protected： 保护成员函数或变量   // 只能被本类的成员函数或其他派生类的成员函数访问和调用。

## 类方法

1. 内联函数的隐式定义， 直接在public等修饰词下定义。
2. 内联函数的显示定义， 在类外面， 定义 前加inline关键字 要加作用域。
3. 非内联函数定义， 在累外面定义  要加作用域。

## 构造函数
1. 带默认参数的构造函数，默认参数在声明里指定，在定义里不能指定   
2. 复制构造函数：常常使用引用，如 类名(const 类名 &引用对象名); 类存在默认的复制构造函数，对每一个成员执行复制操作。但是默认复制构造函数有时候会导致指针悬挂的问题，应为默认的复制构造函数是值得复制，而不是内存的深层复制，即是只是复制指针地址。这就导致前一个类结束生命时释放了内存，后一个类又重复释放内存导致出错。
3. 初始化列表的使用场景
    
    1. 需要初始化的数据成员是对象，这个对象有含参数的构造函数
    2. 需要初始化常成员数据或引用（const修饰的成员数据）
    3. 子类初始化父类的私有成员。
4. 初始化列表执行顺序 
    ***初始化的顺序和其在类中声明时的顺序是一致的，与列表的先后顺序无关， 保证两者顺序一致才能真正保证其效率和准确性。***

## 派生类

```c++
class 类名： 派生方式 基类名
{
    ...
}
```
1. 保护方式：
    1. public: 基类的私有成员在派生类中只能由基类提供的成员函数间接访问。这样的派生类为基类的一个子类。
    2. private：基类的公有和私有成员在派生类中都为私有成员，不能通过派生类的派生或对象访问进行访问。
    3. protected: 基类的公有和保护成员在派生类中都为保护成员。基类的公有成员经过保护派生后不能被派生对象直接访问。
基类的私有成员在派生类中只能由基类提供的成员函数间接访问。
2. 派生类的构造函数和析构函数：
    1. 构造函数
    ```
    派生类名（形参声明）：基类名（参数表0）,对象成员1（参数表1）,对象成员2（参数表2）,...,对象成员n(参数表n)
    {
        ...
    }
    ```
    &emsp;&emsp;传给基类的参数可以是派生构造函数参数也可以是常数。创建一个派生类对象时首先执行基类构造函数，然后执行派生构造函数。
    
    2. 析构函数
    派生类结束时，首先执行派生类的析构函数，然后执行基类的析构函数。
3. 同名成员
    允许同名成员，访问时成员前面加作用域，默认为派生类的作用域。
4. 赋值兼容
    1. 基类指针可以指向其派生类的对象。
    2. 可以将指向派生类对象的指针赋值给基类对象指针。
    3. 可以通过派生类的对象给基类对象赋值，属于派生类但不属于基类的数据成员将被忽略。
    4. 可以使用派生类的对象初始化基类的引用。
    5. 不能将指向派生类对象的指针指向其基类的某个对象。
    6. 不能通过基类对象给派生类对象赋值。

## 继承
1. 多层次单继承
2. 多继承

    ```
    class 派生类名：派生方式 基类名1，派生方式 基类名2....
    {
        ...
    }
    ```
    二义性问题： 在派生类中调用时明确指出调用哪一副本，即时添加作用域，或者采用虚基类。
3. 虚基类
    使公共的基类只产生一个副本，避免出现二义性。

    ```c++
    class 派生类名: virtual 派生方式 基类名
    {
        //virtual 也可以写在派生类后面。
        ...
    }
    ```
    1. 如果虚基类中定义了带参数的构造函数，那么基类所有直接或间接派生类都必须在其构造函数定义中给出对虚基类构造函数的调用。
    2. 虚基类的数据成员的初始化是由其最远的派生类的构造函数对其构造函数的调用完成。
    3. 基类在作为某些类的虚基类时，同时也可以作为其他类的普通的基类。

## 多态性

***一个接口，多种方法***

1. 编译时多态与运行时多态
    - 编译时多态
        多个函数名相同时，编译器在编译阶段能够根据参数的个数和类型的不同确定调用的函数。这种静态多态通过函数重载或运算符重载实现。
    - 运行时多态
        程序在运行时才确定要调用的函数。这种动态多态通过虚函数机制实现。        
2. 运算符重载
    
    1. 通过成员函数实现

        ```
        函数返回值 operator运算符（形参表）
        {
            // 运算符可以是 + - * / > < =  ++ -- 等。。
        }
        ```
    2. 通过友元函数实现
    
        ```
        friend 函数返回值 operator运算符（形参表）;
        ```
    3. 通过类外普通函数实现
    4. "++" "--"
    
        ```c++
            类名 operator++(); // 前缀表达式
            类名 operator++（int i); // 后缀表达式, i 没有实际用处，只用于区别
        ```
    5. 以下运算符不能被重载：
        
        - .
        - .*
        - ::
        - ?:
        - sizeof
        - c++中没有的运算符
        - 不能改变操作符操作数个数
        - 重载参数中必须有一个是类对象或类对象的引用
        
3. 虚函数
    1. 定义与使用
        
        1. 派生类中对虚函数的重载必须完全相同，但有例外：当基函数的虚函数的返回类型为基类的引用或指针时，派生类的虚函数的返回类型可以是派生类的引用或指针
        2. 派生类中对基类虚函数的重载都为虚函数，派生类虚函数的定义前可以省略virtual关键字。
        3. 静态成员函数不能为虚函数。
        4. 构造函数不能为虚函数。
    2. 虚析构函数
        通过虚析构函数可以保证使用delete删除指向派生类对象指针时，能够调用派生类的析构函数 
4. 纯虚函数和抽象类
    1. 定义
        含有纯虚函数的类为抽象类，抽象类不能创建该类的对象，只能作为其他类的基类。
    
        ```
        vitual 函数名（参数表） = 0； //只有声明，没有定义
        ```
    2. 如果抽象了的派生类中没有对纯虚函数进行实现那么它仍为抽象了。
    3. 抽象类可以为一个类族提供一个框架，用于声明公共接口。 

## 模板

1. 函数模板
    建立一个通用函数，函数的参数类型或返回值可以不用具体指定而是使用标识符代替。例如：

    ```c++
    template <typename T> // typename 也可以换成 class
    bool Compare(T a, T b)
    {
        if (a < b)
            return true;
        else
            return false;
    }
    ```
    调用函数模板生成模板函数
    
2. 类模板（参数化的类）
    在定义类时不指定某些数据成员、成员函数的参数或返回值类型，而是使用类型参数代替。

    ```c++
    /* 链表模板类 */
    template <typename T, typename T2, typename T3....>
    class CListNode
    {
        T *m_pData; // 数据指针
        CListNode *m_pNext;
    public:
        CListNode (T *pData)
        {
            m_pdata = pData;
            m_pNext = NULL;
        }
        void Add(CListNode *pNode)
        {
            pNode->m_pNext = this;
            m_pNext = NULL;
        }
        CListNode* GetNext() const // 常函数，只读，函数不允许修改成员变量的值
        {
            return m_pNext;
        }
        T* GetData() const
        {
            return m_pData;
        }
        
    };
    ```
    模板类的使用
    
    ```
        CListNode<CStudent> studentNode(&student1);
    ```
    模板类中的函数在外定义
    
    ```
    CListNode<T>::CListNode(T *pData)
    {
        ...
    }
    ```
    
## C++ 常数
1. 常成员函数

    ```
    void nae() const
    {
        ...
    }
    ```
    常成员函数，只能读取数据成员，不能改变数据成员。这里的const修饰的隐藏指针this,对其他参数没有任何的限制。
2. 常数据成员
    
    ```
    const int num;//声明hour为常数据成员
    ```
    常成员数据的初始化必须在构造函数中使用初始化列表进行初始化。
3. 常对象   
    常对象必须在定义是指明并初始化，如
    
    ```
    Time const time(12,34,56); // 定义常对象time
    // 或者
    const Time time(12,34,56);
    ```
    常对象只能调用常成员函数（const），除了构造和析构函数以外。
    


